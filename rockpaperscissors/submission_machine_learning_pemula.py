# -*- coding: utf-8 -*-
"""Submission Machine Learning Pemula.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zcJVU3m8kBa6QzTaffCrP7rU3tAni51P

Nama : Rijal Muhyidin

Email : rijalmuhyi12@gmail.com

Domisili : Kabupaten Wonosobo, Jawa Tengah
"""

import tensorflow as tf
!pip install split-folders
import splitfolders
import zipfile
import os
import shutil
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from keras.models import Sequential
from keras.layers import Flatten, Dense, Conv2D, MaxPooling2D
import keras
import matplotlib.pyplot as plt
import numpy as np
from google.colab import files
from tensorflow.keras.preprocessing import image
import matplotlib.image as mpimg

!wget --no-check-certificate \
  https://github.com/dicodingacademy/assets/releases/download/release/rockpaperscissors.zip \
  -O /tmp/rockpaperscissors.zip

local_zip = '/tmp/rockpaperscissors.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/tmp/data')
zip_ref.close()

base_dir = '/tmp/data/rockpaperscissors'
output_dir = os.path.join(base_dir, 'main')

rps_dir = os.path.join(base_dir, 'rps-cv-images')
if os.path.exists(rps_dir):
  shutil.rmtree(rps_dir)
  print("Folder berhasil terhapus")

if os.path.exists(os.path.join(base_dir, 'README_rpc-cv-images.txt')):
  os.remove(os.path.join(base_dir, 'README_rpc-cv-images.txt'))
  print("File berhasil terhapus")

splitfolders.ratio(
    base_dir,
    output_dir,
    seed=None,
    ratio=(.6,.4)
)

paper_dir = os.path.join(base_dir, 'paper')
train_paper_dir = os.path.join(output_dir, 'train/paper')
val_paper_dir = os.path.join(output_dir, 'val/paper')

rock_dir = os.path.join(base_dir, 'rock')
train_rock_dir = os.path.join(output_dir, 'train/rock')
val_rock_dir = os.path.join(output_dir, 'val/rock')

scissors_dir = os.path.join(base_dir, 'scissors')
train_scissors_dir = os.path.join(output_dir, 'train/scissors')
val_scissors_dir = os.path.join(output_dir, 'val/scissors')

train_dir = os.path.join(output_dir, 'train')
validation_dir = os.path.join(output_dir, 'val')

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    horizontal_flip=True,
    vertical_flip=True,
    shear_range=0.2,
    fill_mode='nearest',
    brightness_range=[0.8,1.2]
)

validation_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    horizontal_flip=True,
    vertical_flip=True,
    shear_range=0.2,
    fill_mode='nearest',
    brightness_range=[0.8,1.2]
)

train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical'
)

validation_generator = validation_datagen.flow_from_directory(
    validation_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical'
)

model = Sequential([
    Conv2D(16, (3,3), activation='relu', input_shape=(150, 150, 3)),
    MaxPooling2D(2, 2),
    Conv2D(32, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Conv2D(64, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Conv2D(128, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Flatten(),
    Dense(512, activation='relu'),
    Dense(3, activation='softmax')
])

model.summary()

model.compile(
    loss='categorical_crossentropy',
    optimizer=tf.optimizers.RMSprop(learning_rate = 0.001, rho = 0.9),
    metrics=['accuracy']
)

class MyCallback(keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if (logs.get('accuracy') > 0.975):
      print('\nAkurasi sudah cukup, karena melebihi 0.975')
      self.model.stop_training = True

myCallback = MyCallback()

history = model.fit(
    train_generator,
    steps_per_epoch=25,
    epochs=20,
    validation_data=validation_generator,
    validation_steps=5,
    verbose=2,
    callbacks=[myCallback]
)

plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('accuracy plot')
plt.ylabel('value')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('loss plot')
plt.ylabel('value')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

uploaded = files.upload()

for path in uploaded.keys():
 
  img = image.load_img(path, target_size=(150,150))

  imgplot = plt.imshow(img)
  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)

  images = np.vstack([x])
  classes = model.predict(images, batch_size=10) 

  print(path)
  if classes[0,0]==1:
    print('paper')
  elif classes[0,1]==1:
    print('rock')
  else:
    print('scissors')